# Dev Notes <!-- omit in toc -->

This is an additional section for information, generally not relevant for the user but the developers. Here you will find some pitfalls and useful information discovered during coding.

## TOC  <!-- omit in toc -->

- [Python Version](#python-version)
- [DB Schema](#db-schema)
- [Program Schema](#program-schema)
- [Translating the UI](#translating-the-ui)
- [PyQt](#pyqt)
  - [Batch Compile Files](#batch-compile-files)
  - [Creating Styles](#creating-styles)
  - [Button clicked.connect behavior](#button-clickedconnect-behavior)
  - [Those God Damn Buttons](#those-god-damn-buttons)
  - [Scaling an App for High Resolution](#scaling-an-app-for-high-resolution)
- [Other Hardware than RPi](#other-hardware-than-rpi)
- [ToDos](#todos)
  - [In Planning](#in-planning)
  - [Backlog](#backlog)
  - [Done](#done)
- [Templates](#templates)
  - [German: API-Key](#german-api-key)
  - [Write Downs](#write-downs)


# Python Version

Currently used version:

```
Python Version 3.7.x
```

In the past, there were some issues due to not using the same Python version during development (PC) and at production (RPi). To prevent those issues, the same Python version (up to minor) like the current one shipped with the RPi system should be used. This will prevent making errors like using `list` instead of `List` for type hints (only works at Python 3.9+) and other features not yet available in the default RPi Python. Please use an according Python version for your local development.

# DB Schema

In the following diagram, the DB Architecture is shown. The used DB is a SQLite DB.

![ProgramSchema](diagrams/out/DBSchema.svg)

**Notes:** 
- Even if not all fields are mandatory (NOT NULL) they should be initiated with a value of 0, if no other value is desired. This may be changed in the future with a DEFAULT 0 setting. The CocktailBerry app does always assign a value to all fields, so this is only an issue when using a own script for additional data filling
- AUTOINCREMENT ID / PK are generated by SQLite and do not need to be provided when inserting data
- SQLite does not have the boolean type, so an integer representation of `0: false 1: true` was used. This is case in following columns:
  - Hand
  - Enabled
  - Virgin
- Counter / Consumption should be set to 0 when initiating
- The Recipes.Comment field is historical and will probably be removed in the future, since the new DataClass representation takes this job now. Some testing needs to be done to ensure a working app without this column. This can be left as an empty string or null.
- SQLite does only provides a small amount of [alter operations](https://www.sqlite.org/lang_altertable.html), which is also why some columns still got no default value (schema creation was without this constraint).

# Program Schema

In the following diagram, the schema and Classes / Containers are displayed in a simplified version.

![ProgramSchema](diagrams/out/ProgramSchema.svg)

# Translating the UI

One contribution, that does not require any programming skill is the possibility to add a translation to your language.
The language file is found in `src/language.yaml` for CocktailBerry and in `dashboard/frontend/language.yaml` for the Dashboard. In the best szenerio, both files get the according translation. You can use any of the existing language to translate into your own language, in most cases english will probably be the best to use. Please add for every existing option a translation, following the current YAML schema. Using an [ISO 639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_code) **two letter code** language codes is desired.

# PyQt

All Topics related to PyQt (or Qt in general).

## Batch Compile Files

Just use the Script:

```shell
.\scripts\compile_ui_to_python.ps1  
```

## Creating Styles

To manage the style, a qss (qt-css) file is used. [qtsass](https://github.com/spyder-ide/qtsass) is used to convert a sass file into the used qss file. For conversion run:

```bash
qtsass /src/ui/styles/ -o /src/ui/styles/  
```

If you want to implement a new style, copy the default.scss file, rename the copy to your style name and plug your colors into the variables. After that, just compile the file. You got a new style setting. To be supported, the style name needs to be added to the `src.__init__` file into the `SUPPORTED_STYLES` list.

## Button clicked.connect behavior

One issue, which is not clear on the first view, is that there are two signatures for this function. See [this issue on StackOverflow](https://stackoverflow.com/questions/53110309/qpushbutton-clicked-fires-twice-when-autowired-using-ui-form/53110495#53110495) for more details. When using the error logging wrapper and just passing the wrapped function into the connect function, PyQt will also emit the `False` argument into the wrapper. This will result in a crash of the program in case the wrapped function got no arguments. In this case it is better to use a lambda to explicitly tell PyQt the function got no arguments.

```Python
# Wrapped function without arguments
@logerror
def some_function():
  print("Doing Stuff")

# Good
your_button.clicked.connect(lambda: some_function())

# Will crash because the wrapper got *args=(False,)
# and will call some_function(False)
your_button.clicked.connect(some_function)
```

## Those God Damn Buttons

Even if buttons support a icon element, there seem no way to change the icon color over a css property.
You either change the icon file (lol) or adjust the color over the property.
Qtawesome got a color argument. 
It could be used to change the color to the given theme color, but therefore some refactoring is needed.

Example:
```python
from PyQt5.QtCore import QSize
import qtawesome as qta
def _change_cog_icon(self):
    """Changes the option button icon"""
    self.option_button.setIcon(qta.icon("fa5s.cog", color="#007bff"))
    self.option_button.setIconSize(QSize(32, 32))
```

## Scaling an App for High Resolution

If the user uses a high res screen (like 2k+), this app will now work properly.
A possible solution is to divide the resolution by x (e.g. 2) and then set the QT_SCALE_FACTOR to x.
This will effectively run the App at the given lower res, but scale it up to fit the screen.
Example for powershell:

```powershell
$Env:QT_SCALE_FACTOR = "2"
python runme.py
```


# Other Hardware than RPi

There is also the generic board option, which should work with a broad option of other boards.
They only need to be controllable over the GPIO interface, especially with [python-periphery](https://github.com/vsergeev/python-periphery).
Depending on the OS of the system, some set up steps may differ from the RPi ones.
For the Qt GUI its important to run the LXDE or similar Desktop variant.
Gnome or others may break some features like always stays on top or other window settings.

Example for RockPi:

```sh
# launcher
nmcli r wifi on
echo "Waiting for WiFi"
sleep 10
export QT_SCALE_FACTOR=1
cd ~/CocktailBerry/
sudo python3 runme.py
# cocktail.desktop at "/etc/xdg/autostart/"
[Desktop Entry]
Type=Application
Name=CocktailScreen
Terminal=true
Exec=/usr/bin/lxterminal -e sh /home/rock/launcher.sh
```


# ToDos

Here are some todos, for now or later versions:

## In Planning

- [ ] Review microservice and its features
  - [ ] Email always is quite tricky, maybe get something more "working", or just remove it
  - [x] Generally review this logic, maybe extend it to make it work with other custom endpoints using keys are other header auth features
- [ ] Switch from strong private to weak private class methods
- [ ] Import from submodule instead of files in submodule
- [ ] Move all path related vars into one location and import them

## Backlog

- [ ] Use Handadds for defined machine ingredients, if they are there
- [ ] Add possibility to switch units for recipes
  - [x] Rework GUI fields to use dynamic instead of static values
  - [x] Dynamically change label depending on setting
  - [ ] Refactor app logic to work with different units
    - [ ] Make sure microservice always using ml as unit
    - [ ] Evaluate if it makes sense to change db values or just convert them for the frontend
  - [x] Rework input field validators
  - [x] Change number control field to floats
## Done

- [x] Use a approach to change button color without needing new png / svg files
  - [x] Investigate if qtawesome can do the job
  - [x] refactor styles to easier get color data
- [x] Add progress bar to cleaning program and possibility to cancel
- [x] Add possibility to import new recipes over CLI
  - [x] Add CLI command with filepath argument
    - [x] Use optional conservation (option) factor if units are not in ml
  - [x] Add parser for parsing recipe data
    - [x] Evaluate common file structure / type for parsing
  - [x] Add logic to populate DB
- [x] Extent RPi Controller API to be more generic for also other boards
  - [x] Introduce new config var to set board type
  - [x] Add list of supported board types to settings
  - [x] Extend documentation for pin names / numbers
  - [x] Check if setting is in list of supported types
  - [x] Refactor RPi to machine controller
  - [x] New board / pin controller class for machine controller to inherit pin methods from
- [x] Add config management into maker UI
  - [x] replace cleaning with option button
  - [x] own window to have dedicated option settings
  - [x] Get all needed configs from manager
  - [x] Display with correct input option for user
  - [x] Check values before change
- [x] Switch from in file stylesheets to one central stylesheet
  - [x] Create method to inject stylesheet into ui
  - [x] Merge individual stylesheets into one central one
    - [x] Make it to work with any amount of urls / header things
    - [x] Make it work with the official API
  - [x] Review que logic for failed sending
  - [x] Add additional logic for the new official endpoint + api key .env variable slot for example file
  - [x] Extend API for receiving as well as sending of language used and machine name
- [x] Add restart / reboot control into maker UI
- [x] Give the user the possibility to backup and restore CocktailBerry data
  - [x] Option in the UI to import/export data
  - [x] Prompt for user to choose folder for backup
  - [x] Generate own folder with db (and config) file
  - [x] *Optional:* possibility only to export one of both? -> will probably not make this
  - [x] Method / Class to overwrite existing files with backup ones
    - [x] Think of also deleting previously stored files in the backup if overwrite
- [x] Also Send Recipe Data (Ingredients) as Object to the Endpoint. Let the user handle the data.


# Templates

Here are some templates for processes in CocktailBerry

## German: API-Key

Hey USERNAME

Ich schreibe dir hier wegen dem API Key, damit alle Infos gesammelt kommen.
Die offizielle CocktailAPI ist optional, ich biete jedem mit einer Maschine die Nutzung an.

REGELN:
Prinzipiell gelten Regeln, die überall gelten. Sprich:

- Gib weder deiner Machine noch den Cocktails irgendwelche diskriminierenden oder beleidigenden Namen, diese sind sichtbar, wenn Daten gesendet werden
- Behandle den Schlüssel wie ein Passwort, speichere ihn nicht im Code von Projekten, sondern nur einer .env Datei, die nicht mit git committed wird
- Falls der Schlüssel doch komprimiert wird, gib mir einfach Bescheid, ich lösche den aktuellen und generiere einen neuen

Sollten diese missachtet werden, wird der Schlüssel gelöscht.

INSTALLATION:
Um Daten zu senden, muss der microservice installiert werden, dies geht entweder über den:

- alten Weg https://cocktailberry.readthedocs.io/advanced/ -> im CocktailBerry microservice Ordner ' cp .env.example .env' -> in der '.env' Datei den Schlüssel eintragen
- neuen Weg https://hub.docker.com/repository/docker/andrewo92/cocktailberry-microservice/general -> am besten eine Datei 'docker-compose.yaml' außerhalb des Ordners (z.B. Desktop) mit dem Inhalt bei der Seite unter 'Using Docker Compose' erstellen, API Key austauschen.

Dann im selben Ordner einfach 'docker-compose up --build --detach' (oder bei neuen auch 'docker compose up --build --detach') ausführen. Der Service startet dann immer automatisch mit dem System. Merke, dafür muss natürlich Docker + Compose Installiert sein. In den CocktailBerry Optionen kannst du dann jederzeit mit dem Häkchen bei 'MICROSERVICE_ACTIVE' die Interaktion mit diesem an-/ausschalten. Wenn sich Änderungen am Code oder deiner .env ergeben, einfach den Befehl noch mal ausführen.

Die Daten sind dann auf dem Dashboard (https://stats-cocktailberry.streamlit.app/) zu sehen. Unter der Route https://stats-cocktailberry.streamlit.app/?partymode=true werden direkt nur Daten der letzten 24h angezeigt. Das ist für Gäste deiner Party nützlich, um live die Daten zu verfolgen.

BITTE BEI TESTS AUSSCHALTEN MIT EINER AUSNAHME
Bitte denke daran, dass wenn das Set-Up fertig ist, die Daten von produzierten Cocktails gesendet werden, oder temporär gespeichert und später gesendet werden, wenn keine Internet Verbindung besteht. Das heißt: Wenn du Tests oder ähnliches machst, solltest du mindestens das Häkchen bei 'MICROSERVICE_ACTIVE' entfernen, damit nicht die Testdaten fälschlicherweise gesendet werden. Das Senden der Daten sollte nur geschehen, wenn auch ein "normaler" Betrieb der Maschine ist. Wenn du testen willst, ob der Key richtig
eingerichtet ist, kannst du einen neuen Cocktail mit dem Namen "testcocktail" (alles klein, Zutaten egal) erstellen und den zubereiten / an die API schicken. Cocktails mit diesem Namen werden alle 20 Minuten von der Datenbank gelöscht. Mit "docker logs cocktail-microservice" und in den CocktailBerry Logs können mögliche Fehler ausgelesen werden, um zu ermitteln warum der Service nicht wie gedacht funktioniert. 

HALL OF FAME
Gerne füge ich auch deine Maschine in die „Hall of Fame“ hinzu. Diese ist auf https://stats-cocktailberry.streamlit.app/ unten bei „Existing Machines“. So können auch andere Nutzer sich von dir inspirieren lassen. Dafür benötige ich ein oder zwei aussagekräftige, gut belichtete Bilder von (am besten Vollansicht) der Maschine. Zudem einen Name (oder Alias) von dem Besitzer, als auch den Namen der Maschine, am besten den Gleichen, wie in den Optionen benannt. Gerne auch noch 2-5 Sätze in Deutsch/Englisch über die Maschine. Als Beispiele kannst du die schon existierenden Einträge anschauen.

EIGENER ENDPOINT
Alternativ existiert im microservice auch 'HOOK_ENDPOINT', wenn du die Daten lieber an einen eigenen Endpunkt senden willst. Mit 'HOOK_HEADERS' kannst du auch Authentifizierung und co. mitsenden. Ich verwende das zum Beispiel, um die Daten an mein Smarthome zu senden.
So als Tipp: Wird der Standardwert bei 'HOOK_ENDPOINT' / 'API_KEY' gelassen, oder der Variable ganz entfernt, sendet der Service dahin nichts, auch wenn er aktiv ist.

DER KEY
So, dein Key ist: APIKEY 😊

Viele Grüße und vor allem viel Spaß mit CocktailBerry
SENDERNAME 


## Write Downs
